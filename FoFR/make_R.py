"""
Function which makes a new instance of the R script. 
"""

LINES = ["# R script to run the GAMA group finder on G19\n",
    "library(FoF)\n",
    "library(celestial)\n",
    "library(data.table)\n",
    "library(yaml)\n",
    "\n",
    "# Parse command-line arguments\n",
    "args <- commandArgs(trailingOnly = TRUE)\n",
    "\n",
    "# Validate input\n",
    "if (length(args) != 2) {\n",
    "  stop('Usage: Rscript run_fofr.R <input_yaml_file> <output_file>')\n",
    "}\n",
    "\n",
    "input_file <- args[1]  # Path to the YAML parameter file\n",
    "output_file <- args[2] # Path to the output file\n",
    "\n",
    "# Create the interpolated functions which will be used\n",
    "redshift = seq(0, 1, by=1e-4)\n",
    "k_corrections <- {}\n",
    "for (i in 1:length(redshift)){\n",
    "  k_corrections = c(k_corrections, KEcorr(redshift[i])[2])} #K+E corrections\n",
    "\n",
    "# Creating the redshift to distance modulus and distance modulus to redshift functions.\n",
    "z_to_mod_matrix = data.frame(redshift = redshift, distance_modulus = cosdistDistMod(redshift, OmegaM=0.25, OmegaL=0.75, H0=100)+k_corrections)\n",
    "z_to_dmod = approxfun(z_to_mod_matrix[,1], z_to_mod_matrix[,2])\n",
    "dmod_to_z = approxfun(z_to_mod_matrix[,2], z_to_mod_matrix[,1])\n",
    "\n",
    "data(LFswml) # reading in the LF as given in the FoF package. (exclusive for GAMA)\n",
    "cut=-14\n",
    "tempLFswml = LFswml[LFswml[,2]< cut,c(2,3)]\n",
    "tempLFswml = cbind(tempLFswml,2*tempLFswml[,2]*(1/sqrt(LFswml[LFswml[,2]< cut,4])))\n",
    "tempLFswmlLum = tempLFswml\n",
    "LFswmlfunc = approxfun(tempLFswml[,1],tempLFswml[,2],rule=c(2,2))\n",
    "LFswmlfuncLum = approxfun(tempLFswml[,1],tempLFswml[,2]*10^(-0.4*tempLFswml[,1]),rule=c(2,2))\n",
    "\n",
    "#Integrating over the luminosity functions in both magnitude and luminosity\n",
    "integrated_lf_values = {} #values in the lf function in mag\n",
    "integrated_lf_values_lum = {} #value in the lf function in luminosities\n",
    "for(i in 1:length(tempLFswml[,1])){\n",
    "  integrated_lf_values = c(\n",
    "    integrated_lf_values, integrate(\n",
    "      LFswmlfunc, lower=-30, upper=tempLFswml[i,1], subdivisions=1e3)$value)}\n",
    "\n",
    "for(i in 1:length(tempLFswmlLum[,1])){\n",
    "  integrated_lf_values_lum = c(\n",
    "    integrated_lf_values_lum, integrate(\n",
    "      LFswmlfuncLum, lower=-30, upper=tempLFswml[i,1], subdivisions=1e3, stop.on.error=F)$value)}\n",
    "\n",
    "minaddswml=min(integrated_lf_values[integrated_lf_values>0])\n",
    "minaddswmlLum=min(integrated_lf_values_lum[integrated_lf_values_lum>0])\n",
    "integrated_lf_values[integrated_lf_values==0]=minaddswml\n",
    "integrated_lf_values_lum[integrated_lf_values_lum==0]=minaddswmlLum\n",
    "tempLFswml=cbind(tempLFswml,integrated_lf_values)\n",
    "tempLFswmlLum=cbind(tempLFswmlLum,integrated_lf_values_lum)\n",
    "LFswmlintfunc=approxfun(tempLFswml[,1],tempLFswml[,4],rule=c(2,2))\n",
    "LFswmlintfuncLum=approxfun(tempLFswmlLum[,1], tempLFswmlLum[,4], rule=c(2,2))\n",
    "#\n",
    "#\n",
    "#\n",
    "#\n",
    "#Randoms stuff:\n",
    "RanCat = fread('gen_ran_out.randoms.csv')\n",
    "N = 1e4\n",
    "G09area = skyarea(c(129,141), c(-2,3))\n",
    "G12area = skyarea(c(174,186), c(-3,2))\n",
    "G15area = skyarea(c(211.5,223.5), c(-2,3))\n",
    "gama_fraction_sky = sum(G09area['areafrac'], G12area['areafrac'], G15area['areafrac'])\n",
    "\n",
    "distfunc_z2D = cosmapfunc('z', 'CoDist', H0=100, OmegaM=0.25, OmegaL=0.75, zrange=c(0,1), step='a', res=N) # redshift to comoving distance\n",
    "distfunc_D2z = cosmapfunc('CoDist', 'z', H0=100, OmegaM=0.25, OmegaL=0.75, zrange=c(0,1), step='a', res=N) # comoving distance to redshift\n",
    "RanCat[,'CoDist'] = distfunc_z2D(RanCat[,z])\n",
    "GalRanCounts = dim(RanCat)[1]/400 # Don't know where this 400 comes from.\n",
    "\n",
    "#smooth out the histogram of comoving distances\n",
    "bin = 40\n",
    "temp = density(RanCat[,CoDist], bw = bin/sqrt(12), from=0, to=2000, n=N, kern='rect')\n",
    "rm(RanCat)\n",
    "tempfunc = approxfun(temp$x, temp$y, rule=2) # create a function that maps Distance to frequency\n",
    "# integrate over the density as a function of distance\n",
    "tempint = {}\n",
    "for (colim in seq(0, 2000, len=N)){\n",
    "  tempint=c(tempint, integrate(tempfunc, colim-bin/2, colim+bin/2)$value)} # not sure I get this exactly\n",
    "\n",
    "# work out the comoving volume at each bin.\n",
    "radii = seq(0, 2000, len=N)\n",
    "volume_of_shells = ((4/3)*pi*(radii + bin/2))**3 - ((4/3)*pi*(radii - bin/2))**3 \n",
    "\n",
    "RunningVolume = gama_fraction_sky*volume_of_shells\n",
    "RunningDensity_D = approxfun(temp$x, GalRanCounts*tempint/RunningVolume, rule=2) \n",
    "RunningDensity_z = approxfun(distfunc_D2z(temp$x), GalRanCounts*tempint/RunningVolume, rule=2)\n",
    "#\n",
    "#\n",
    "#\n",
    "############################\n",
    "# Running the Group Finder #\n",
    "###########################\n",
    "\n",
    "# read in the data\n",
    "g09 = fread('./deep_field_group_finding.dat')\n",
    "g09[,'AB_r'] = g09[,r_VST_ap] - z_to_dmod(g09[,zobs])\n",
    "g09 = as.data.frame(g09)\n",
    "#I'm just assuming 100% completeness and I should have a look at the way Aaron does the completeness stuff.\n",
    "#\n",
    "#\n",
    "### Reading in the parameters that need to be optimized by the emcee routine ###\n",
    "params = yaml.load_file(input_file)\n",
    "\n",
    "data(circsamp)\n",
    "cat=FoFempint(\n",
    "  data=g09, bgal=params$b_gal, rgal=params$r_gal, Eb=params$Eb, Er=params$Er, \n",
    "  coscale=T, NNscale=3, groupcalc=T, precalc=F, halocheck=F, apmaglim=19.8, colnames=colnames(g09), \n",
    "  denfunc=LFswmlfunc, intfunc=RunningDensity_z, intLumfunc=LFswmlintfuncLum, \n",
    "  useorigind=T,dust=0,scalemass=1,scaleflux=1,extra=F,\n",
    "  MagDenScale=params$mag_den_scale,deltacontrast=params$delta_contrast,deltarad=params$delta_rad,deltar=params$delta_r,\n",
    "  circsamp=circsamp,Mmax=1e15, zvDmod = z_to_dmod, Dmodvz = dmod_to_z,\n",
    "  left=211.5, right=223.5, top = 2.47, bottom = -2.54)\n",
    "\n",
    "# Write the group_references to file (used for tuning)\n",
    "# Convert grefs to a data frame to preserve the column structure\n",
    "grefs_df <- as.data.frame(cat$grefs)\n",
    "write.table(grefs_df, file = output_file, row.names = FALSE, col.names = FALSE)\n"]

def make_r(outfile: str) -> None:
    """
    Makes a copy of the R file that we have.
    """
    with open(outfile, 'w', encoding='utf-8') as file:
        for line in LINES:
            file.write(line)
